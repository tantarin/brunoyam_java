Переопределение метода (англ. Method overriding) — это возможность реализовать метод так, чтобы он имел идентичную сигнатуру с методом класса-предка, но предоставлял иное поведение. Так же это один из инструментов реализации полиморфизма.

Переопределяя метод — обязательно помечайте его аннотацией @Override! Это не только спасет от потенциальных ошибок, но и повысит читаемость кода.

```
class Animal {
   public void move() {
      System.out.println("Животные могут двигаться");
   }
}

class Dog extends Animal {
   public void move() {
      System.out.println("Собаки могут ходить и бегать");
   }
}

public class TestDog {

   public static void main(String args[]) {
      Animal a = new Animal();   // Animal - ссылка и объект
      Animal b = new Dog();   // Animal - ссылка, но Dog - объект

      a.move();   // Запускает метод в классе Animal
      b.move();   // Запускает метод в классе Dog
   }
}
```
В вышеприведённом примере вы можете заметить, что b хоть и является типом Animal, оно запускает метод move в классе Dog. Причина тому: во время компиляции проходит проверка ссылочного типа. Однако, во время выполнения, JVM определяет тип объекта и запускает метод, который принадлежит этому конкретному объекту.

Рассмотрите следующий пример:

```
class Animal {
   public void move() {
      System.out.println("Животные могут двигаться");
   }
}

class Dog extends Animal {
   public void move() {
      System.out.println("Собаки могут ходить и бегать");
   }
   public void bark() {
      System.out.println("Собаки могут лаять");
   }
}

public class TestDog {

   public static void main(String args[]) {
      Animal a = new Animal();   // Animal - ссылка и объект
      Animal b = new Dog();   // Animal - ссылка, но Dog - объект

      a.move();   // Запускает метод в классе Animal
      b.move();   // Запускает метод в классе Dog
      b.bark();
   }
}
```

Программа выдаст ошибку во время компиляции, так как ссылочный тип b у Animal не имеет метода под именем bark.

-Список аргументов должен быть точно таким же, как и для переопределённого метода.
-Возвращаемый тип должен быть таким же или подтипом возвращаемого типа, объявленного в исходном переопределенном методе в суперклассе.
-Уровень доступа не может быть более ограниченным, чем уровень доступа переопределённого метода. Например, если метод суперкласса объявлен public, то переопределяемый метод в подклассе не может быть private или protected.
