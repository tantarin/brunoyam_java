@RestController — это составная аннотация, которая сама мета-аннотируется аннотациями @Controller и @ResponseBody, указывая на контроллер, каждый метод которого наследует аннотацию @ResponseBody на уровне типов и, следовательно, осуществляет запись непосредственно в тело ответа вместо распознавания представления и визуализации при помощи HTML-шаблона.

REST предлагает брать в качестве уникального идентификатора для единицы ресурса (к примеру товар или пользователь) url адрес, а определять действие с этой единицей - по типу запроса.

RESTful архитектура подразумевает использовать весь спектр запросов: GET - получить данные, POST - отправить новые данные, PUT - отправить отредактированные данные, DELETE - удалить данные. Есть ещё PATCH, который по своей идеи повторяет PUT, различия лишь в том, что PUT предполагает заменить полностью запись, а PATCH только частично обновить данные. Что интересно, мнения об использовании POST и PUT расходятся. Англоязычные разработчики предпочитают использовать именно PUT для добавления новых данных, а POST для редактирования.

 Если вы аннотируете метод с помощью @ResponseBody, Spring попытается преобразовать его возвращаемое значение и автоматически записать его в ответ http. Если вы аннотируете параметр методов с помощью @RequestBody, Spring на лету попытается преобразовать содержимое тела входящего запроса в ваш объект параметра.
 
 @RequestMapping - это одна из основных аннотаций в Spring, которая сопоставляет HTTP-запросы (URL-адреса) с методами.
 
 Наиболее часто используемый атрибут - это method который позволяет нам указать и сузить метод запроса, который обрабатывает наш метод ( GET , POST , DELETE и т. Д.):
 
 ```
  @RequestMapping(value = "/addProduct", method = RequestMethod.POST) 
 public String addProductPost(@ModelAttribute("product") Product product) { 
 // some code 
 } 
 ```
 
 Если мы не указываем метод запроса, метод запроса по умолчанию - GET .
 
 Многие веб-сайты полагаются на переменные пути, чтобы продемонстрировать конечному пользователю конкретный продукт, страницу, профиль и т. Д., Например example.com/viewProduct/324 , где 324 - это идентификатор продукта:
 
 ```
 @RequestMapping("/viewProduct/{productId}") 
 public String viewProduct(@PathVariable int productId, Model model) { 
 Product product = productService.getProductById(productId); 
 model.addAttribute("product", product); 
 return "viewProduct"; 
 } 
 ```
 
 ```
  @RequestMapping("/users/{username}") 
 public String viewUser(@PathVariable("username") String username) { 
 Profile profile = profileService.getProfileByUsername(username); 
 // rest of the code 
 } 
 ```
 
 Существуют буквально только сокращенные версии для отображений выше, где @PostMapping("/hello") равно @RequestMapping(value="/hello", RequestMethod.POST) .
 
 ```
 <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
  ```
  
   @Entity. Эта аннотация перед классом укажет Hibernate, что это не просто класс, а специальный класс, объекты которого нужно хранить в базе данных.
   
   
   **Пример**
   
   ```
        @RestController
        @RequestMapping("/api")
        public class StudentController {
            StudentService studentservice;
            @Autowired
            public StudentController(StudentService studentservice) {
                this.studentservice = studentservice;
            }
            @GetMapping(value="/students")
            public List<Student> getAllStudents(){
                return studentservice.getAllStudents();
            }           
            @GetMapping(value="/students/{id}")
            public Student getStudentById(@PathVariable("id") @Min(1) int id) {
                Student std = studentservice.findById(id)
                                            .orElseThrow(()->new StudentNotFoundException("Student with "+id+" is Not Found!"));
                return std;
            }           
            @PostMapping(value="/students")
            public Student addStudent(@Valid @RequestBody Student std) {
                return studentservice.save(std);
            }           
            @PutMapping(value="/students/{id}")
            public Student updateStudent(@PathVariable("id") @Min(1) int id, @Valid @RequestBody Student newstd) {
                Student stdu = studentservice.findById(id)
                                             .orElseThrow(()->new StudentNotFoundException("Student with "+id+" is Not Found!"));
                stdu.setFirstname(newstd.getFirstname());
                stdu.setLastname(newstd.getLastname());
                stdu.setEmail(newstd.getEmail());
                return studentservice.save(stdu);   
            }           
            @DeleteMapping(value="/students/{id}")
            public String deleteStudent(@PathVariable("id") @Min(1) int id) {
                Student std = studentservice.findById(id)
                                             .orElseThrow(()->new StudentNotFoundException("Student with "+id+" is Not Found!"));
                studentservice.deleteById(std.getId());
                return "Student with ID :"+id+" is deleted";            
            }
        }
        ```
        
     ***RequestBody**
     
  ```
      @RequestMapping(value="/employees", method=RequestMethod.POST)
      public Employee createEmployee(@RequestBody Employee emp) {
      return empService.createEmployee(emp);
      }
```

***POSTMAN***

API — описание способов, взаимодействия одной компьютерной программы с другими. Этот контракт определяет, как они взаимодействуют друг с другом, используя запросы и ответы. Документация API содержит информацию о том, как разработчики должны структурировать эти запросы и ответы.

API могут быть разными. Самый востребованный из них — REST. REST определяет набор функций, таких как GET, PUT, DELETE и т. д., которые клиенты могут использовать для доступа к данным сервера. Клиенты и серверы обмениваются данными по протоколу HTTP.
Иногда, помимо акронима REST, можно встретить слово RESTful. Это не термин, но в сообществе его применяют к веб-сервисам, которые соответствуют REST-архитектуре. RESTful используют как прилагательное.

Клиент — программа, которая запрашивает у сервера доступ к ресурсам. Для этого она использует API. Когда ваш браузер запрашивает у сервера веб-страницу, он выступает в роли клиента.
Получается структура, при которой клиент направляет к серверу запрос, а в ответ получает ресурсы. Такое разделение позволяет создавать клиент и сервер независимо друг от друга, что ускоряет и упрощает разработку.

Представим, что вы делаете сервис для учёта деловых переписок. Сами переписки хранятся на сервере, а доступ к ним можно получить из мобильного приложения. Оно не будет хранить никаких данных — только отправлять запросы на сервер, получать ответы и отображать их на экране смартфона.

Если вы когда-нибудь захотите полностью изменить логику работы сервера, то это никак не отразится на мобильном приложении. До тех пор, пока они понимают запросы и ответы друг друга, конечно.

А чтобы дать доступ к сервису из десктопного приложения и личного сайта, достаточно написать два новых клиента — а на сервере ничего менять не надо. Такая вот гибкость.

Допустим, мы разрабатываем веб приложение, которое способно хранить информацию о клиентах и их заказах. Т.е. наша система способна манипулировать некоторыми сущностями: создавать их, редактировать, удалять, выдавать информацию о них. 

Этими сущностями будут:

clients — клиенты;

orders — заказы клиентов;

items — товары.

В REST архитектуре клиенты отправляют на сервер запросы для получения или модификации данных, а сервера отправляют клиентам ответы на их запросы. 

Клиентские запросы практически всегда сделаны по протоколу HTTP. В общем, HTTP запросы состоят из нескольких составляющих: 

-HTTP метод;

-заголовок;

-URI;

-тело запроса.

Данные, которые получают или изменяют клиенты посредством запросов, называют ресурсами. Основа клиент-серверного взаимодействия — манипуляция над ресурсами. 

Ресурсы в REST — это все, чему можно дать имя. Это в каком то смысле как классы в Java. В Java мы можем создать класс для чего угодно. Так и в REST — ресурсом может быть что угодно: пользователь, документ, отчет, заказ. 

В рамках нашего примера у нас есть 3 ресурса: 

-clients — клиенты;

-orders — заказы клиентов;

-items — товары.

Если говорить очень просто, эндпоинт — это что-то вроде адреса в сети. Если углубляться в суть, можно сказать, что эндпоинт — это URI.

Клиенты отправляют запросы на так называемые эндпоинты, или же конечные точки (end point).

У каждого конкретного ресурса должен быть уникальный URI. Ответственность за то, чтобы у каждого ресурса всегда был свой URI лежит на плечах разработчика сервера. 

URI в REST принято начинать с множественной формы существительного, описывающего некоторый ресурс. Например, со слова clients. Далее через слэш указывают ID — идентификатор некоторого конкретного клиента. Примеры: 

-/clients — URI всех имеющихся клиентов;

-/clients/23 — URI конкретного клиента, а именно клиента с ID=23;

Мы можем продолжить URI, добавив к нему заказы: 

-/clients/4/orders — URI всех заказов клиента №4;

-/clients/1/orders/12 — URI заказа №12 клиента №1.

Существует несколько общепринятых методов HTTP. Перечислим те из них, которые наиболее часто используются в RESTful сервисах: 

-GET — служит для получения информации о конкретном ресурсе (через ID) либо о коллекции ресурсов;

-POST — служит для создания нового ресурса;

-PUT — служит для изменения ресурса (через ID);

-DELETE — служит для удаления ресурса (через ID).

В запросах, как собственно и в ответах, присутствуют HTTP заголовки. В них отправляется дополнительная информация о запросе (либо ответе). Заголовки представляют собой пары ключ-значение.

Применительно к REST клиенты часто могут слать в запросе к серверу заголовок Accept. Он нужен, чтобы дать серверу понять, в каком формате клиент ожидает получить от него ответ.

Различные варианты форматов представлены в так называемом списке MIME-типов.

Каждый MIME тип состоит из двух частей, разделяемых слэшем — из типа и подтипа. Примеры MIME-типов для разных видов файлов: 

text — text/plain, text/css, text/html;

image — image/png, image/jpeg, image/gif;

audio — audio/wav, audio/mpeg;

video — video/mp4, video/ogg;

application — application/json, application/pdf, application/xml, application/octet-stream.

Итого, у запроса может присутствовать заголовок: 

Accept:application/json или Accept: text/html, application/xhtml+xml, application/xml

Данный заголовок говорит серверу, что клиент ожидает получить ответ в JSON формате.

Есть у запроса тело или нет, зависит от типа HTTP запроса. 

Например, запросы GET и DELETE как правило не содержат никакого тела запроса. 

А вот PUT и POST могут содержать: тут все дело в функциональном назначении типа запроса. Ведь для получения данных и удаления по id (который передается в URL) не нужно слать на сервер дополнительные данные. 

А вот для создания нового ресурса (запрос POST) нужно этот ресурс передать. Также как и для модификации существующего ресурса. 

В REST для передачи тела запроса чаще всего используют форматы XML или JSON. Наиболее часто встречается JSON формат. 

Предположим, мы хотим отправить на сервер запрос, а в нем — создать новый ресурс. 

Тогда телом такого запроса может быть следующий JSON: 

```
{
  "name" : "Amigo",
  "email" : "amigo@jr.com",
  "phone" : "+7 (191) 746-43-23"
}
```

***ПРИМЕРЫ***

```
GET /clients/23
Accept : application/json, application/xml
```

```
POST /clients
{
  "name" : "Amigo",
  "email" : "amigo@jr.com",
  "phone" : "+7 (191) 746-43-23"
}
```

```
PUT /clients/1
{
  "name" : "Ben",
  "email" : "bigben@jr.com",
  "phone" : "+380 (190) 346-42-13"
}
```

```
DELETE /clients/12/orders/6
```

Ответ как правило состоит из следующих частей: 
код ответа;
заголовки;
тело ответа.
В целом заголовки ответов мало чем отличаются от заголовков запросов. К тому же, некоторые заголовки используются и в ответах, и в запросах. 

В теле часто возвращается информация которую запросил клиент. Может возвращаться в том же формате JSON информация на GET запросы. 


   
 
