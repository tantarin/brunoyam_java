1. **Что такое конструктор?**

Конструктор - это специальный метод, который вызывается при создании нового объекта.
Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.
```
class Box {
    int width; // ширина коробки
    int height; // высота коробки
	
    // Конструктор
    Box() {
        width = 10;
        height = 10;
    }
}
```

Существуют три базовых типа конструкторов в Java:

• Конструктор по умолчанию (default constructor)

Данный конструктор создается автоматически компилятором.

• Конструктор без аргументов (no-args constructor)

• Параметризованный конструктор (parameterized constructor)

Конструкторы располагаются сразу после полей в порядке, зависящем от принимаемых ими числа аргументов — от меньшего к большему.
Конструктор может принимать в качестве аргумента как примитивные типы данных, так и объекты.
Класс может содержать любое количество конструкторов.

3. **Какие существуют модификаторы доступа?**

В Java используются следующие модификаторы доступа:

public: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.

private: закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.

protected: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах

Модификатор по умолчанию. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

4. **На какие основные группы можно поделить типы данных?**

В Java типы данных делят на две большие группы: примитивные и ссылочные. В состав примитивных типов (или просто примитивов) входят четыре подвида и восемь типов данных:

1) целые числа (byte, short, int, long);
2) числа с плавающей точкой (float, double);
3) логический (boolean);
4) символьный (char).

Ссылочные типы данных ещё называют ссылками. К ним относятся все классы, интерфейсы, массивы, а также тип данных String.

5. **Какие примитивные типы вы знаете?**

В состав примитивных типов (или просто примитивов) входят четыре подвида и восемь типов данных:

целые числа (byte, short, int, long);

числа с плавающей точкой (float, double);

логический (boolean);

символьный (char).

6. **Что Вы знаете о массивах?**

В Java массивы являются объектами.
Массив  — это контейнер для хранения однотипных значений, количество которых было задано заранее.
Пример создания массива со строковыми значениями:
```
String[] strArray = {"Java","is","the","best","language"};
```
Если создается пустой массив с некоторым количеством ячеек, то всем элементам массива будут присваиваться значения по умолчанию. Например:
```
int[] arr = new int[10];
```
Так, для массива с элементами типа boolean начальные значения будут равны false, для массивов с числовыми значениями — 0, с элементами типа char — \u0000. Для массива типа класса (объекты) — null.
После объявления массива определенного размера сам размер нельзя изменить. Чтобы добавить новый элемент в массив, необходимо создать новый массив большего размера и скопировать в него все элементы со старого.

7. **Что вы знаете о классах оболочках?**

В java есть примитивные типы данных (такие, как int, short, boolean и т.д.).  У примитивных типов есть объекты-аналоги - так называемые "классы оболочки", или "wrapper" (с англ. "обертка, упаковка").

![](/images/Wrap_1.png)

Класс называется "оболочкой" потому, что он, по сути, копирует то, что уже существует, но добавляет новые возможности для работы с привычными типами.
Но зачем они нужны? Если есть обычный int, short, ..., зачем нам Short и Integer? Или, может, оставить только классы оболочки, и не пользоваться примитивами, раз у них функций больше? 
Например, обычный int занимает меньше места, и если нет необходимости проводить над ним особые операции, Ваш компьютер будет работать быстрее.
В свою очередь, с помощью класса-оболочки Integer можно выполнять специальные операции - например, перевести текст в число:
```
    String s="200";    
    int i=Integer.parseInt(s);
```
Кроме того, есть ситуации, когда нельзя использовать объекты, или наоборот, когда можно использовать только объекты.
Java автоматически производит преобразования между примитивными типами и их обертками:
```
Integer j = 1;          // autoboxing
int i = new Integer(1); // unboxing
```

8. **Когда стоит использовать перечисления (enum) в Java?**

С помощью перечислений обычно представляют группу констант. Создаются они с помощью ключевого слова enum и разделенных запятой констант.

```
public enum ThreadStatesEnum {
    START,
    RUNNING,
    WAITING,
    DEAD;
}
```

Все классы перечислений происходят от стандартного класса java.lang.Enum, от которого наследуют ряд потенциально полезных методов.

Из наследуемых методов следует знать следующие: name(), ordinal() и статический values().

Метод name() возвращает имя в точности, как оно определено в значении перечисления. Метод ordinal() возвращает численное значение, отражающее порядок, в котором были объявлены перечисления, начиная с нуля. 
Метод values() пригождается чаще. Он возвращает массив из всех значений перечисления и может использоваться для их перебора.

Enum в Java в основном улучшает безопасность типов.

9. **Для чего используется ключевое слово static?**

Модификатора static - с англ.  "статичный", "постоянный" - делает переменную или метод "независимыми" от объекта. 

Если нужно объявить любую константу - например, \pi  = 3,14 - обязательно нужно использовать static. Они объявляются с использованием сочетание "static final".

```
public static final double pi= 3.14159265359;
```
В независимости от количества созданных объектов класса — всегда будет существовать только один экземпляр статического поля. Значение такого поля будет единым и общим для всех объектов класса, содержащих это поле.

Подобно статическим полям, статические методы также принадлежат классу, а не объекту, поэтому их можно вызывать без создания экземпляра класса, в котором они находятся. При этом следует помнить, что из статического метода можно получить доступ только к статическим переменным или к другим статическим методам.

10. **Динамическое и статическое связывание** (раннее и позднее связывание)

Вызов метода в Java означает, что этот метод привязывается к конкретному коду или в момент компиляции, или во время выполнения, при запуске программы и создании объектов. 

Статическое связывание используется в языке Java для разрешения перегруженных методов, в то время как динамическое связывание используется в языке Java для разрешения переопределенных методов.

В случае статического связывания используются не конкретные объекты, а информация о типе, то есть для обнаружения нужного метода используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода в Java используется конкретный объект.

```
public class Main {
    public static void main(String... s) {
        Base b = new Child();
        b.show(); //выведет child
    }
}
class Base {
    void show() {
        System.out.println("Base");
    }
}
class Child extends Base {
    void show() {
        System.out.println("Child");
    }
}
```

11. **Что такое перегрузка методов в ООП или Java?**

Перегрузка методов — это приём программирования, который позволяет разработчику в одном классе для методов с разными параметрами использовать одно и то же имя. В этом случае мы говорим, что метод перегружен.

```
public class Calculator {
  void calculate(int number1, int number2) { }
  void calculate(double number1, double number2, double number2) { }
}
```
Использование перегрузки делает ваш код чище и проще для чтения, а также помогает избежать ошибок в программе.

Вы не можете перегрузить метод, изменяя возвращаемое значение в сигнатуре метода.

Следующий код не скомпилируется:

```
public class Calculator {
  double calculate(int number1, int number2){return 0.0;}
  long calculate(int number1, int number2){return 0;}
}
```

12. **Композиция и агрегация**

Наследование описывает связь «является» (или по-английски «IS A»). Лев является Животным. Если класс HeavyBox наследует Box, мы говорим, что HeavyBox является Box.
Однако не все связи отношения в мире описываются таким образом. К примеру, клавиатура определенно как-то связана с компьютером, но она не является компьютером.
В этих случаях в его основе лежит другой тип отношения: не «является», а «является частью» («HAS A»). 

Ассоциация – это когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет». Автомобиль имеет двигатель.
Выделяют два частных случая ассоциации: композицию и агрегацию.

Композиция – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем.

Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра.

13. **Когда использовать абстрактный класс, а когда интерфейс**

Представим, что нам нужно описать несколько животных — и у каждого будет свой класс. Мы соберём их характеристики, опишем в полях и методах. У некоторых животных характеристики будут совпадать — например, и у гепарда, и у коня 4 ноги. А у некоторых — не совпадут: кролик ест траву, а тигр — других животных.

Однако, несмотря на несовпадение, мы можем выделить шаблонные характеристики: количество лап, издаваемый звук, приём пищи, передвижение. Эти шаблонные характеристики мы можем собрать в одном месте — абстрактном классе «Животное».

Так на практике реализуется абстракция — процесс выделения наиболее важных характеристик объекта и информации об объекте.

Интерфейс описывает только поведение (методы), и у него нет полей. Точнее, есть возможность их объявить, но они будут public static final. В то же время абстрактный класс может содержать классические поля, которые будут принадлежать разным объектам.

В абстрактных классах наследуемый класс используется в отношении IS-A — то есть класс-наследник только расширяет функциональность абстрактного класса.

