1) Что такое конструктор
2) Какие существуют модификаторы доступа?
3) На какие основные группы можно поделить типы данных
4) Какие примитивные типы вы знаете
5) Что Вы знаете о массивах
6) Что вы знаете о классах оболочках
7) Когда стоит использовать перечисления (enum) в Java
8) Для чего используется ключевое слово static
9) Динамическое и статическое связывание
10) Что такое перегрузка методов в Java
11) Переопределение методов в Java
12) Композиция и агрегация
13) Когда использовать абстрактный класс, а когда интерфейс
14) Иерархия коллекций
15) Что представляет собой полиморфизм
16) String в Java
17) Equals и HashCode
18) Что такое wildcard
19) Что такое generics
20) Класс Object и его методы


1. **Что такое конструктор?**

Конструктор - это специальный метод, который вызывается при создании нового объекта.
Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.
```
class Box {
    int width; // ширина коробки
    int height; // высота коробки
	
    // Конструктор
    Box() {
        width = 10;
        height = 10;
    }
}
```

Существуют три базовых типа конструкторов в Java:

• Конструктор по умолчанию (default constructor)

Данный конструктор создается автоматически компилятором.

• Конструктор без аргументов (no-args constructor)

• Параметризованный конструктор (parameterized constructor)

Конструкторы располагаются сразу после полей в порядке, зависящем от принимаемых ими числа аргументов — от меньшего к большему.
Конструктор может принимать в качестве аргумента как примитивные типы данных, так и объекты.
Класс может содержать любое количество конструкторов.

2. **Какие существуют модификаторы доступа?**

В Java используются следующие модификаторы доступа:

public: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.

private: закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.

protected: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах

Модификатор по умолчанию. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

3. **На какие основные группы можно поделить типы данных?**

В Java типы данных делят на две большие группы: примитивные и ссылочные. В состав примитивных типов (или просто примитивов) входят четыре подвида и восемь типов данных:

1) целые числа (byte, short, int, long);
2) числа с плавающей точкой (float, double);
3) логический (boolean);
4) символьный (char).

Ссылочные типы данных ещё называют ссылками. К ним относятся все классы, интерфейсы, массивы, а также тип данных String.

4. **Какие примитивные типы вы знаете?**

В состав примитивных типов (или просто примитивов) входят четыре подвида и восемь типов данных:

целые числа (byte, short, int, long);

числа с плавающей точкой (float, double);

логический (boolean);

символьный (char).

5. **Что Вы знаете о массивах?**

В Java массивы являются объектами.
Массив  — это контейнер для хранения однотипных значений, количество которых было задано заранее.
Пример создания массива со строковыми значениями:
```
String[] strArray = {"Java","is","the","best","language"};
```
Если создается пустой массив с некоторым количеством ячеек, то всем элементам массива будут присваиваться значения по умолчанию. Например:
```
int[] arr = new int[10];
```
Так, для массива с элементами типа boolean начальные значения будут равны false, для массивов с числовыми значениями — 0, с элементами типа char — \u0000. Для массива типа класса (объекты) — null.
После объявления массива определенного размера сам размер нельзя изменить. Чтобы добавить новый элемент в массив, необходимо создать новый массив большего размера и скопировать в него все элементы со старого.

6. **Что вы знаете о классах оболочках?**

В java есть примитивные типы данных (такие, как int, short, boolean и т.д.).  У примитивных типов есть объекты-аналоги - так называемые "классы оболочки", или "wrapper" (с англ. "обертка, упаковка").

![](/images/Wrap_1.png)

Класс называется "оболочкой" потому, что он, по сути, копирует то, что уже существует, но добавляет новые возможности для работы с привычными типами.
Но зачем они нужны? Если есть обычный int, short, ..., зачем нам Short и Integer? Или, может, оставить только классы оболочки, и не пользоваться примитивами, раз у них функций больше? 
Например, обычный int занимает меньше места, и если нет необходимости проводить над ним особые операции, Ваш компьютер будет работать быстрее.
В свою очередь, с помощью класса-оболочки Integer можно выполнять специальные операции - например, перевести текст в число:
```
    String s="200";    
    int i=Integer.parseInt(s);
```
Кроме того, есть ситуации, когда нельзя использовать объекты, или наоборот, когда можно использовать только объекты.
Java автоматически производит преобразования между примитивными типами и их обертками:
```
Integer j = 1;          // autoboxing
int i = new Integer(1); // unboxing
```

7. **Когда стоит использовать перечисления (enum) в Java?**

С помощью перечислений обычно представляют группу констант. Создаются они с помощью ключевого слова enum и разделенных запятой констант.

```
public enum ThreadStatesEnum {
    START,
    RUNNING,
    WAITING,
    DEAD;
}
```

Все классы перечислений происходят от стандартного класса java.lang.Enum, от которого наследуют ряд потенциально полезных методов.

Из наследуемых методов следует знать следующие: name(), ordinal() и статический values().

Метод name() возвращает имя в точности, как оно определено в значении перечисления. Метод ordinal() возвращает численное значение, отражающее порядок, в котором были объявлены перечисления, начиная с нуля. 
Метод values() пригождается чаще. Он возвращает массив из всех значений перечисления и может использоваться для их перебора.

Enum в Java в основном улучшает безопасность типов.

8. **Для чего используется ключевое слово static?**

Модификатора static - с англ.  "статичный", "постоянный" - делает переменную или метод "независимыми" от объекта. 

Если нужно объявить любую константу - например, \pi  = 3,14 - обязательно нужно использовать static. Они объявляются с использованием сочетание "static final".

```
public static final double pi= 3.14159265359;
```
В независимости от количества созданных объектов класса — всегда будет существовать только один экземпляр статического поля. Значение такого поля будет единым и общим для всех объектов класса, содержащих это поле.

Подобно статическим полям, статические методы также принадлежат классу, а не объекту, поэтому их можно вызывать без создания экземпляра класса, в котором они находятся. При этом следует помнить, что из статического метода можно получить доступ только к статическим переменным или к другим статическим методам.

9. **Динамическое и статическое связывание** (раннее и позднее связывание)

Вызов метода в Java означает, что этот метод привязывается к конкретному коду или в момент компиляции, или во время выполнения, при запуске программы и создании объектов. 

Статическое связывание используется в языке Java для разрешения перегруженных методов, в то время как динамическое связывание используется в языке Java для разрешения переопределенных методов.

В случае статического связывания используются не конкретные объекты, а информация о типе, то есть для обнаружения нужного метода используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода в Java используется конкретный объект.

```
public class Main {
    public static void main(String... s) {
        Base b = new Child();
        b.show(); //выведет child
    }
}
class Base {
    void show() {
        System.out.println("Base");
    }
}
class Child extends Base {
    void show() {
        System.out.println("Child");
    }
}
```

10. **Что такое перегрузка методов в Java?**

Перегрузка методов — это приём программирования, который позволяет разработчику в одном классе для методов с разными параметрами использовать одно и то же имя. В этом случае мы говорим, что метод перегружен.

```
public class Calculator {
  void calculate(int number1, int number2) { }
  void calculate(double number1, double number2, double number2) { }
}
```
Использование перегрузки делает ваш код чище и проще для чтения, а также помогает избежать ошибок в программе.

Вы не можете перегрузить метод, изменяя возвращаемое значение в сигнатуре метода.

Следующий код не скомпилируется:

```
public class Calculator {
  double calculate(int number1, int number2){return 0.0;}
  long calculate(int number1, int number2){return 0;}
}
```
11. **Переопределение методов**

Переопределение метода (англ. Method overriding) в объектно-ориентированном программировании — одна из возможностей языка программирования, позволяющая подклассу или дочернему классу обеспечивать специфическую реализацию метода, уже реализованного в одном из суперклассов или родительских классов.

Переопределенный метод вызывается в соответствии с объектом, которому принадлежит метод, а не по типу ссылки.

При переопределении метода он должен иметь уровень доступа не меньше, чем уровень доступа в базовом класса. Например, если в базовом классе метод имеет модификатор public, то и в производном классе метод должен иметь модификатор public.

У переопределенного метода должны быть те же аргументы, что и у метода родителя.

У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя.

Модификатор доступа у переопределенного метода также не может отличаться от «оригинального».

Используйте аннотацию Override, чтобы компилятор мог проверить, что вы действительно переопределяете метод, когда вы на это рассчитываете. Таким образом, если вы совершаете распространенную ошибку, например, опечатку в имени метода или неправильно задаете параметры, вы будете предупреждены о том, что ваш метод фактически не переопределяет в то время, как вы уверены в обратном. Во-вторых, это улучшает читаемость кода, делая переопределение более очевидным.


12. **Композиция и агрегация**

Наследование описывает связь «является» (или по-английски «IS A»). Лев является Животным. Если класс HeavyBox наследует Box, мы говорим, что HeavyBox является Box.
Однако не все связи отношения в мире описываются таким образом. К примеру, клавиатура определенно как-то связана с компьютером, но она не является компьютером.
В этих случаях в его основе лежит другой тип отношения: не «является», а «является частью» («HAS A»). 

Ассоциация – это когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет». Автомобиль имеет двигатель.
Выделяют два частных случая ассоциации: композицию и агрегацию.

Композиция – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем.

Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра.

13. **Когда использовать абстрактный класс, а когда интерфейс**

Представим, что нам нужно описать несколько животных — и у каждого будет свой класс. Мы соберём их характеристики, опишем в полях и методах. У некоторых животных характеристики будут совпадать — например, и у гепарда, и у коня 4 ноги. А у некоторых — не совпадут: кролик ест траву, а тигр — других животных.

Однако, несмотря на несовпадение, мы можем выделить шаблонные характеристики: количество лап, издаваемый звук, приём пищи, передвижение. Эти шаблонные характеристики мы можем собрать в одном месте — абстрактном классе «Животное».

Так на практике реализуется абстракция — процесс выделения наиболее важных характеристик объекта и информации об объекте.

Интерфейс описывает только поведение (методы), и у него нет полей. Точнее, есть возможность их объявить, но они будут public static final. В то же время абстрактный класс может содержать классические поля, которые будут принадлежать разным объектам.

В абстрактных классах наследуемый класс используется в отношении IS-A — то есть класс-наследник только расширяет функциональность абстрактного класса.

14. **Иерархия коллекций**

На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: Collection и Map. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» (словари).

![](/images/r.png)

![](/images/w.png)

![](/images/q.png)

![](/images/e.png)

![](/images/t.png)


16. **Что представляет собой полиморфизм**

Полиморфизм — или способность объекта выполнять специализированные действия на основе его типа.

Мы постоянно используем полиморфизм в базовых классах Java. Один очень простой пример — создание экземпляра класса ArrayList с объявлением типа как интерфейс List.

```
List<String> list = new ArrayList<>();
```
Или рассмотрим следующий пример:

```
public interface Swim {
    void swim();
}

class Human implements Swim {
    private String name;
    private int age;

    public Human(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public void swim() {
        System.out.println(Я плаваю с помощью надувного круга.");
    }
}

class Fish implements Swim{
    private String name;

    public Fish(String name) {
        this.name = name;
    }

    @Override
    public void swim() {
        System.out.println("Я рыба " + name + ". Я плыву, двигая плавниками.");

    }
}

public class Main {

    public static void main(String[] args) {
        Swim human = new Human("Антон", 6);
        Swim fish = new Fish("кит");

        List<Swim> swimmers = Arrays.asList(human, fish);
        for (Swim s : swimmers) {
            s.swim();
        }
    }
}
```

Каким образом происходит выбор нужной реализации метода при выполнении программы? В Java по умолчанию используется позднее связывание (на стадии выполнения программы, а не во время компиляции, как в случае с ранним связыванием). Это значит, что при компиляции такого кода компилятор еще не знает, код из какого класса — Human или Fish он будет исполнять в методе swim. Это определится только при выполнении программы благодаря механизму динамической диспетчеризации — проверки типа объекта во время выполнения программы и выбора нужной реализации метода для этого типа. 

В Java благодаря полиморфизму можно:

- создавать "одноименные методы" в одном классе ("перегрузка методов")

- изменить поведение методов родительского класса ("переопределение методов").


18. **String в Java**

При работе со строками важно понимать, что объект String является неизменяемым (immutable). То есть при любых операциях над строкой, которые изменяют эту строку, фактически будет создаваться новая строка. 

Все объекты класса String виртуальная машина хранит в пуле строк. Когда мы создаем строку используя двойные кавычки, виртуальная машина Java ищет в пуле строк другую строку с таким же значением. Если строка найдена, то возвращается только ссылка на существующий объект класса String, иначе создается новый объект с полученным значением, и сохраняется в пул.

Когда мы используем оператор new, виртуальная машина создает объект String, но не хранит его в пуле строк. Мы можем использовать метод intern() для сохранения строки в пуле строк, или получения ссылки, если такая строка уже находится в пуле.

Манипуляции со строками ресурсоемкие, поэтому Java обеспечивает два полезных класса для манипуляций со строками – StringBuffer и StringBuilder.

StringBuffer и StringBuilder являются изменяемыми классами. Операции с StringBuffer потокобезопасны и синхронизированы, а методы StringBuilder не потокобезопасны. Поэтому когда несколько нитей работают с одной строкой, мы должны использовать StringBuffer, но в однопоточном окужении мы должны использовать StringBuilder.

StringBuilder более производительный, чем StringBuffer, поскольку не обременен синронизацией.


17. **Equals и HashCode**

С примитивами всё просто. Мы сравниваем через == и всё хорошо. Но почему нельзя аналогично делать с объектами? Потому что == сравнивает по ссылкам, а не по параметрам объекта. 

Чтобы сравнивать именно по параметрам надо переопределять метод equals. Метод Equals проверяет два объекта одного происхождения на логическую равность. 

Используя equals, мы должны придерживаться основных правил, определённых в спецификации Java:

-Рефлексивность — x.equals(x) возвращает true.

-Симметричность — x.equals(y) <=> y.equals(x).

-Транзитивность — x.equals(y) <=> y.equals(z) <=> x.equals(z).

-Согласованность — повторный вызов x.equals(y) должен возвращать значение предыдущего вызова, если сравниваемые поля не изменялись.

-Сравнение null — x.equals(null) возвращает false.

HashCode → это обычное значение int, которое соответствует объекту.

Есть несколько простых правил:

Для одного объекта хэшкод всегда одинаковый и не меняется. Т.е. мы не можем переопределить метод и генерировать там рандомное число;

При генерации хэшкода надо использовать все параметры, а не какой-то один. Т.е. в классе Cat не стоит писать, что hashCode = 31, а то получится, что у всех котов он одинаковый и весь смысл теряется.

У двух разных объектов может быть одинаковый hashCode. Почему так происходит? Дело в том, что hashCode ограничен интовым значением. Там есть диапазон, поэтому результат может повторяться.

У двух одинаковых объектов всегда одинаковые хэшкоды.

Если хэшкоды разные, то объекты всегда разные.

При сравнении объектов сначала удобно проверить на равенство хэшкодов и только потом сравнивать через equals. Так быстрее по скорости, потому что equals → немного медленно работает. Гораздо быстрее сравнивать два числа и просто не проверять дальше, если они не равны.

Общие правила для сравнения объектов:

-Если есть два объекта и они равны по equals, то и hashCode их равны. Если не равны, то неправильно реализовали.

-Если два объекта не равны по equals, то hashCode могут быть равны, а могут и нет. Потому что Int ограничение. 

18. **Что такое wildcard**

Wildcard — это дженерик вида <?>, что означает, что тип может быть чем угодно. Используется, например, в коллекциях, где для всех коллекций базовым типом является Сollection<?>.

Например, если вы хотите написать метод, который работает с List<Integer> , List<Double>  и List<Number> , вы можете достичь этого с помощью ограниченного сверху подстановочного символа.

Чтобы наложить ограничение на wildcard необходимо использовать конструкции типа:

- ? extends SomeClass — означает, что может быть использован любой класс-наследник SomeClass
	
- ? super SomeClass — означает, что может быть использован класс SomeClass, либо класс-родитель (или интерфейс) SomeClass
	
Это называется bounded wildcard.
	
Пример использования wildcard:
	
```

public void unbox(Box<?> box) 
{
  System.out.println(box.get());
}
```
	
19. **Что такое generics**
	
Generics — это параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра. Обобщения добавили в язык безопасность типов.

Обобщения или generics (обобщенные типы и методы) позволяют нам уйти от жесткого определения используемых типов. Обобщения позволяют не указывать конкретный тип, который будет использоваться.

```
class Account<T>{
     
    private T id;
    private int sum;
     
    Account(T id, int sum){
        this.id = id;
        this.sum = sum;
    }
     
    public T getId() { return id; }
    public int getSum() { return sum; }
    public void setSum(int sum) { this.sum = sum; }
}
```

В именах переменных типа принято использовать заглавные буквы. Обычно для коллекций используется буква E, буквами K и V — типы ключей и значение (Key/Value), а буквой T (и при необходимости буквы S и U) — любой тип.
	


20. **Класс Object и его методы**

Каждый класс, включая массивы, является потомком java.lang.Object. Всего в java.lang.Object представлено 11 public-методов, 6 из которых имеют нативную реализацию. Так как все классы в Java являются потомками java.lang.Object, то все эти методы унаследованы каждым классом в Java. 

-toString
-clone
-hashCode
-equals
-finalize
-getClass
-wait(long timeout)
-notify()
-notifyAll()

21. **Почему массив строк предпочтительнее строки для хранения пароля?**

Строка неизменяемая в Java и хранится в пуле строк. С тех пор, как она была создана, она остается в пуле, пока не будет удалена сборщиком мусора, поэтому, когда мы думаем, что закончили работу с паролем, он остается доступным в памяти некоторое время, и нет способа избежать этого. Это риск безопасности, поскольку кто-либо, имеющий доступ к дампу памяти сможет найти пароль в виде чистого текста.

Если мы используем массив символов для хранения пароля, мы можем очистить его после того, как закончим с ним работать. Таким образом, мы можем контролировать, как долго он находится в памяти, что позволяет избежать риска безопасности, свойственного строке.

22. **Как вы проверите две строки на подобность в Java?**

Есть два способа проверить, являются ли две строки эквивалентными – используя оператор “==”, или используя метод equals. Когда мы используем оператор “==”, он проверяет значение строки, как ссылки, но в программировании большую часть времени мы проверяем эквивалентность строки только для значения. Поэтому мы должны использовать метод equals для проверки двух строк на эквивалентность.

Еще есть метод equalsIgnoreCase, который мы можем использовать для игнорирования регистра.

23. **Почему строка является популярным ключем в HashMap в Java?**

Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета. Это делает строки отличным кандидатом для ключа в Map и они обрабатываются быстрее, чем другие объекты-ключи HashMap. Вот почему строки преимущественно используются в качестве ключей HashMap.

24. Как устроена HashMap

HashMap — структура из пар «ключ-значение». Внутри это динамический массив ключей. Каждый элемент массива — своеобразная «корзинка», которая хранит связанный список со значением.

![](/images/hm.png)

Связанный список нужен, чтобы избежать коллизий.

Для оптимизации доступа используется хэш ключа. Когда в HashMap добавляют ключ и значение, для ключа сразу высчитывается хэш. По нему определяется позиция в массиве для этой пары: для расчета есть специальные формулы.

HashMap — динамическая структура, то есть количество «корзинок» может изменяться. По умолчанию сущность создается с 16 «корзинками», но это поведение можно поменять при создании, для чего надо задать хэш-таблице начальный размер вручную. Когда элементов в ней становится больше, чем корзинок, структура удлиняется — перезаписывает массив на новый, с большей длиной. По умолчанию длина увеличивается вдвое.

Может случиться так, что у двух разных ключей окажется одинаковый хэш. Или хэш будет разным, но по формуле позиция для обоих хэшей будет одинаковой. Тогда значения обоих ключей окажутся записаны в одну «корзинку». Это и есть коллизия. Именно из-за коллизий для хранения значений используется связанный список: если бы в массиве просто хранился объект, любая коллизия перезаписала бы текущее значение, а это опасно. А при текущей реализации, даже если случится коллизия, новое значение просто запишется в начало той же «корзинки», не изменив старое.

![](/images/hm2.png)

25. Что такое лямбда

Лямбда-выражение или просто лямбда в Java — упрощённая запись анонимного класса, реализующего функциональный интерфейс.

```
(parameter list) -> lambda body
```

Функциональный интерфейс в Java — интерфейс, в котором объявлен только один абстрактный метод. Однако, методов по умолчанию (default) такой интерфейс может содержать сколько угодно.

Пример простого функционального интерфейса:

```
@FunctionalInterface
public interface CarFilter {

    boolean test(Car car);
}
```

Допустим, нам нужна реализация CarFilter, описанного выше, которая проверяла бы, что автомобиль выпущен не раньше 2010 года.

```
CarFilter carFilter = car -> car.getYear() >= 2010;
// or JDK11+
var carFilter = (CarFilter) car -> car.getYear() >= 2010;
```

26. Stream API

Stream API — это набор инструментов, представленных в Java 8 для помощи в обработке последовательности элементов. Вы можете использовать эту функцию, чтобы уменьшить объем шаблонного кода и повысить производительность приложения. Это также помогает создавать более читаемые программы и позволяет нам удобно выполнять массовую обработку.

Каждый промежуточный метод получает на вход результат выполнения с предыдущего этапа (стрим), отвечает только за свою часть работы и возвращает стрим.

Последний (терминальный) метод либо не возвращает значения (void), либо возвращает результат иного, нежели стрим, типа.

Получить список всех книг библиотеки, отсортированных по году издания:

```
Library library = new Library();
List list = library.getBooks().stream()
       .sorted(Comparator.comparing(Book::getIssueYear))
       .collect(Collectors.toList());
```

Или

```
List<EmailAddress> addresses = library.getReaders().stream()
       .filter(Reader::isSubscriber)
       .filter(reader -> reader.getBooks().size() > 1)               
       .map(Reader::getEmail).map(EmailAddress::new)
       .collect(Collectors.toList());
```

27. Встроенные функциональные интерфейсы

![](/images/fun.jpg)

Predicate<T>

Consumer<T>

Function<T,R>

Supplier<T>

UnaryOperator<T>

BinaryOperator<T>

Функциональный интерфейс Predicate<T> проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true. В качестве параметра лямбда-выражение принимает объект типа T:

```
public interface Predicate<T> {
    boolean test(T t);
}

import java.util.function.Predicate;
 
public class LambdaApp {
 
    public static void main(String[] args) {
         
        Predicate<Integer> isPositive = x -> x > 0;
         
        System.out.println(isPositive.test(5)); // true
        System.out.println(isPositive.test(-7)); // false
    }
}
```

BinaryOperator<T> принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию и возвращает ее результат также в виде объекта типа T:

```
public interface BinaryOperator<T> {
    T apply(T t1, T t2);
}
```

28. heap и stack память в Java.

29. сборщик мусора

30. ключевое слово final

Модификатор final - предназначен для создания констант. Если мы пропишем final перед типом данных для переменной, то такую переменную нельзя будет изменить в дальнейшем. Если перед классом прописать слово final, то такой класс не сможет иметь никаких классов наследников.

final переменная класса, объявленная как не static, должна инициализироваться при объявлении или в теле конструктора или блоке инициализации, иначе произойдет ошибка компиляции.

Кроме переменных, объявленными как final могут быть параметры метода и локальные переменные. final переменные, объявленные как static, должны быть проинициализированы при объявлении или в блоке инициализации, также объявленном как static. В противном случае опять получится ошибка компиляции. 

31. передача по ссылке и значению

Данные передаются между методами через параметры. Есть два способа передачи параметров:

-Передача по значению (by value). Значения фактических параметров копируются. Вызываемый метод создает свою копию значений аргументов и затем ее использует. Поскольку работа ведется с копией, на исходный параметр это никак не влияет.

-Передача по ссылке (by reference). Параметры передаются как ссылка (адрес) на исходную переменную. Вызываемый метод не создает свою копию, а ссылается на исходное значение. Следовательно, изменения, сделанные в вызываемом методе, также будут отражены в исходном значении.

В Java переменные хранятся следующим образом:

-Локальные переменные, такие как примитивы и ссылки на объекты, создаются в стеке.

-Объекты — в куче (heap).

**Java всегда передает параметры по значению**

```
Cat A = new Cat ();
doStuff (А);

void doStuff (Cat B) {

   / / Использование B
}
```

Вы можете изменить объект, на который ссылается А, но вы не можете взять и изменить ссылку А — переадресовать её на другой объект или null. Так что если вы измените ссылку B (не сам объект Cat на который ссылается B, а само значение ссылки) вы не измените значение А. И наоборот.

Для примитивных типов — вы передаете копию текущего значения, для ссылок на объекты — вы передаете копию ссылки. Вы никогда не передаете объект. Все объекты хранятся в куче.

32. блоки инициализации 

Существует всего два типа блоков:

-нестатический (instance initializer)

-статический (class initializer)

Cтатический блок используется для инициализации статических переменных, а "обычный"  - для всех остальных.

```
class Dog{
 
    private String name;
    private String poroda;
    private int age;
 
    {
        name = "Шарик";
        poroda = "овчарка";
        age = 2;
    }
 
    public Dog(String x, String y, int z){
        name = x;
        poroda = y;
        age = z;
    }
}
```

