1) Что такое конструктор
2) Какие существуют модификаторы доступа?
3) На какие основные группы можно поделить типы данных
4) Какие примитивные типы вы знаете
5) Что Вы знаете о массивах
6) Что вы знаете о классах оболочках
7) Когда стоит использовать перечисления (enum) в Java
8) Для чего используется ключевое слово static
9) Динамическое и статическое связывание
10) Что такое перегрузка методов в Java
11) Переопределение методов в Java
12) Композиция и агрегация
13) Когда использовать абстрактный класс, а когда интерфейс
14) Иерархия коллекций
15) Что представляет собой полиморфизм
16) String в Java
17) Equals и HashCode
18) Что такое wildcard
19) Что такое generics
20) Класс Object и его методы


1. **Что такое конструктор?**

Конструктор - это специальный метод, который вызывается при создании нового объекта.
Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.
```
class Box {
    int width; // ширина коробки
    int height; // высота коробки
	
    // Конструктор
    Box() {
        width = 10;
        height = 10;
    }
}
```

Существуют три базовых типа конструкторов в Java:

• Конструктор по умолчанию (default constructor)

Данный конструктор создается автоматически компилятором.

• Конструктор без аргументов (no-args constructor)

• Параметризованный конструктор (parameterized constructor)

Конструкторы располагаются сразу после полей в порядке, зависящем от принимаемых ими числа аргументов — от меньшего к большему.
Конструктор может принимать в качестве аргумента как примитивные типы данных, так и объекты.
Класс может содержать любое количество конструкторов.

2. **Какие существуют модификаторы доступа?**

В Java используются следующие модификаторы доступа:

public: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.

private: закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.

protected: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах

Модификатор по умолчанию. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

3. **На какие основные группы можно поделить типы данных?**

В Java типы данных делят на две большие группы: примитивные и ссылочные. В состав примитивных типов (или просто примитивов) входят четыре подвида и восемь типов данных:

1) целые числа (byte, short, int, long);
2) числа с плавающей точкой (float, double);
3) логический (boolean);
4) символьный (char).

Ссылочные типы данных ещё называют ссылками. К ним относятся все классы, интерфейсы, массивы, а также тип данных String.

4. **Какие примитивные типы вы знаете?**

В состав примитивных типов (или просто примитивов) входят четыре подвида и восемь типов данных:

целые числа (byte, short, int, long);

числа с плавающей точкой (float, double);

логический (boolean);

символьный (char).

5. **Что Вы знаете о массивах?**

В Java массивы являются объектами.
Массив  — это контейнер для хранения однотипных значений, количество которых было задано заранее.
Пример создания массива со строковыми значениями:
```
String[] strArray = {"Java","is","the","best","language"};
```
Если создается пустой массив с некоторым количеством ячеек, то всем элементам массива будут присваиваться значения по умолчанию. Например:
```
int[] arr = new int[10];
```
Так, для массива с элементами типа boolean начальные значения будут равны false, для массивов с числовыми значениями — 0, с элементами типа char — \u0000. Для массива типа класса (объекты) — null.
После объявления массива определенного размера сам размер нельзя изменить. Чтобы добавить новый элемент в массив, необходимо создать новый массив большего размера и скопировать в него все элементы со старого.

6. **Что вы знаете о классах оболочках?**

В java есть примитивные типы данных (такие, как int, short, boolean и т.д.).  У примитивных типов есть объекты-аналоги - так называемые "классы оболочки", или "wrapper" (с англ. "обертка, упаковка").

![](/images/Wrap_1.png)

Класс называется "оболочкой" потому, что он, по сути, копирует то, что уже существует, но добавляет новые возможности для работы с привычными типами.
Но зачем они нужны? Если есть обычный int, short, ..., зачем нам Short и Integer? Или, может, оставить только классы оболочки, и не пользоваться примитивами, раз у них функций больше? 
Например, обычный int занимает меньше места, и если нет необходимости проводить над ним особые операции, Ваш компьютер будет работать быстрее.
В свою очередь, с помощью класса-оболочки Integer можно выполнять специальные операции - например, перевести текст в число:
```
    String s="200";    
    int i=Integer.parseInt(s);
```
Кроме того, есть ситуации, когда нельзя использовать объекты, или наоборот, когда можно использовать только объекты.
Java автоматически производит преобразования между примитивными типами и их обертками:
```
Integer j = 1;          // autoboxing
int i = new Integer(1); // unboxing
```

7. **Когда стоит использовать перечисления (enum) в Java?**

С помощью перечислений обычно представляют группу констант. Создаются они с помощью ключевого слова enum и разделенных запятой констант.

```
public enum ThreadStatesEnum {
    START,
    RUNNING,
    WAITING,
    DEAD;
}
```

Все классы перечислений происходят от стандартного класса java.lang.Enum, от которого наследуют ряд потенциально полезных методов.

Из наследуемых методов следует знать следующие: name(), ordinal() и статический values().

Метод name() возвращает имя в точности, как оно определено в значении перечисления. Метод ordinal() возвращает численное значение, отражающее порядок, в котором были объявлены перечисления, начиная с нуля. 
Метод values() пригождается чаще. Он возвращает массив из всех значений перечисления и может использоваться для их перебора.

Enum в Java в основном улучшает безопасность типов.

8. **Для чего используется ключевое слово static?**

Модификатора static - с англ.  "статичный", "постоянный" - делает переменную или метод "независимыми" от объекта. 

Если нужно объявить любую константу - например, \pi  = 3,14 - обязательно нужно использовать static. Они объявляются с использованием сочетание "static final".

```
public static final double pi= 3.14159265359;
```
В независимости от количества созданных объектов класса — всегда будет существовать только один экземпляр статического поля. Значение такого поля будет единым и общим для всех объектов класса, содержащих это поле.

Подобно статическим полям, статические методы также принадлежат классу, а не объекту, поэтому их можно вызывать без создания экземпляра класса, в котором они находятся. При этом следует помнить, что из статического метода можно получить доступ только к статическим переменным или к другим статическим методам.

9. **Динамическое и статическое связывание** (раннее и позднее связывание)

Вызов метода в Java означает, что этот метод привязывается к конкретному коду или в момент компиляции, или во время выполнения, при запуске программы и создании объектов. 

Статическое связывание используется в языке Java для разрешения перегруженных методов, в то время как динамическое связывание используется в языке Java для разрешения переопределенных методов.

В случае статического связывания используются не конкретные объекты, а информация о типе, то есть для обнаружения нужного метода используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода в Java используется конкретный объект.

```
public class Main {
    public static void main(String... s) {
        Base b = new Child();
        b.show(); //выведет child
    }
}
class Base {
    void show() {
        System.out.println("Base");
    }
}
class Child extends Base {
    void show() {
        System.out.println("Child");
    }
}
```

10. **Что такое перегрузка методов в Java?**

Перегрузка методов — это приём программирования, который позволяет разработчику в одном классе для методов с разными параметрами использовать одно и то же имя. В этом случае мы говорим, что метод перегружен.

```
public class Calculator {
  void calculate(int number1, int number2) { }
  void calculate(double number1, double number2, double number2) { }
}
```
Использование перегрузки делает ваш код чище и проще для чтения, а также помогает избежать ошибок в программе.

Вы не можете перегрузить метод, изменяя возвращаемое значение в сигнатуре метода.

Следующий код не скомпилируется:

```
public class Calculator {
  double calculate(int number1, int number2){return 0.0;}
  long calculate(int number1, int number2){return 0;}
}
```
11. **Переопределение методов**

Переопределение метода (англ. Method overriding) в объектно-ориентированном программировании — одна из возможностей языка программирования, позволяющая подклассу или дочернему классу обеспечивать специфическую реализацию метода, уже реализованного в одном из суперклассов или родительских классов.

Переопределенный метод вызывается в соответствии с объектом, которому принадлежит метод, а не по типу ссылки.

При переопределении метода он должен иметь уровень доступа не меньше, чем уровень доступа в базовом класса. Например, если в базовом классе метод имеет модификатор public, то и в производном классе метод должен иметь модификатор public.

У переопределенного метода должны быть те же аргументы, что и у метода родителя.

У переопределенного метода должен быть тот же тип возвращаемого значения, что и у метода родителя.

Модификатор доступа у переопределенного метода также не может отличаться от «оригинального».

Используйте аннотацию Override, чтобы компилятор мог проверить, что вы действительно переопределяете метод, когда вы на это рассчитываете. Таким образом, если вы совершаете распространенную ошибку, например, опечатку в имени метода или неправильно задаете параметры, вы будете предупреждены о том, что ваш метод фактически не переопределяет в то время, как вы уверены в обратном. Во-вторых, это улучшает читаемость кода, делая переопределение более очевидным.



12. **Композиция и агрегация**

Наследование описывает связь «является» (или по-английски «IS A»). Лев является Животным. Если класс HeavyBox наследует Box, мы говорим, что HeavyBox является Box.
Однако не все связи отношения в мире описываются таким образом. К примеру, клавиатура определенно как-то связана с компьютером, но она не является компьютером.
В этих случаях в его основе лежит другой тип отношения: не «является», а «является частью» («HAS A»). 

Ассоциация – это когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет». Автомобиль имеет двигатель.
Выделяют два частных случая ассоциации: композицию и агрегацию.

Композиция – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем.

Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра.

13. **Когда использовать абстрактный класс, а когда интерфейс**

Представим, что нам нужно описать несколько животных — и у каждого будет свой класс. Мы соберём их характеристики, опишем в полях и методах. У некоторых животных характеристики будут совпадать — например, и у гепарда, и у коня 4 ноги. А у некоторых — не совпадут: кролик ест траву, а тигр — других животных.

Однако, несмотря на несовпадение, мы можем выделить шаблонные характеристики: количество лап, издаваемый звук, приём пищи, передвижение. Эти шаблонные характеристики мы можем собрать в одном месте — абстрактном классе «Животное».

Так на практике реализуется абстракция — процесс выделения наиболее важных характеристик объекта и информации об объекте.

Интерфейс описывает только поведение (методы), и у него нет полей. Точнее, есть возможность их объявить, но они будут public static final. В то же время абстрактный класс может содержать классические поля, которые будут принадлежать разным объектам.

В абстрактных классах наследуемый класс используется в отношении IS-A — то есть класс-наследник только расширяет функциональность абстрактного класса.

14. **Иерархия коллекций**
15. **Что представляет собой полиморфизм**
16. **String в Java**

При работе со строками важно понимать, что объект String является неизменяемым (immutable). То есть при любых операциях над строкой, которые изменяют эту строку, фактически будет создаваться новая строка.

17. **Equals и HashCode**

С примитивами всё просто. Мы сравниваем через == и всё хорошо. Но почему нельзя аналогично делать с объектами? Потому что == сравнивает по ссылкам, а не по параметрам объекта. 

Чтобы сравнивать именно по параметрам надо переопределять метод equals. Метод Equals проверяет два объекта одного происхождения на логическую равность. 

Используя equals, мы должны придерживаться основных правил, определённых в спецификации Java:

-Рефлексивность — x.equals(x) возвращает true.

-Симметричность — x.equals(y) <=> y.equals(x).

-Транзитивность — x.equals(y) <=> y.equals(z) <=> x.equals(z).

-Согласованность — повторный вызов x.equals(y) должен возвращать значение предыдущего вызова, если сравниваемые поля не изменялись.

-Сравнение null — x.equals(null) возвращает false.

HashCode → это обычное значение int, которое соответствует объекту.

Есть несколько простых правил:

Для одного объекта хэшкод всегда одинаковый и не меняется. Т.е. мы не можем переопределить метод и генерировать там рандомное число;

При генерации хэшкода надо использовать все параметры, а не какой-то один. Т.е. в классе Cat не стоит писать, что hashCode = 31, а то получится, что у всех котов он одинаковый и весь смысл теряется.

У двух разных объектов может быть одинаковый hashCode. Почему так происходит? Дело в том, что hashCode ограничен интовым значением. Там есть диапазон, поэтому результат может повторяться.

У двух одинаковых объектов всегда одинаковые хэшкоды.

Если хэшкоды разные, то объекты всегда разные.

При сравнении объектов сначала удобно проверить на равенство хэшкодов и только потом сравнивать через equals. Так быстрее по скорости, потому что equals → немного медленно работает. Гораздо быстрее сравнивать два числа и просто не проверять дальше, если они не равны.

Общие правила для сравнения объектов:

-Если есть два объекта и они равны по equals, то и hashCode их равны. Если не равны, то неправильно реализовали.

-Если два объекта не равны по equals, то hashCode могут быть равны, а могут и нет. Потому что Int ограничение. 

18. **Что такое wildcard**

Например, если вы хотите написать метод, который работает с List<Integer> , List<Double>  и List<Number> , вы можете достичь этого с помощью ограниченного сверху подстановочного символа.

Чтобы объявить ограниченный сверху подстановочный символ, используйте символ вопроса «?», с последующим клчевым словом extends , с последующим ограничением сверху.
	
	
19. **Что такое generics**

Обобщения или generics (обобщенные типы и методы) позволяют нам уйти от жесткого определения используемых типов. Обобщения позволяют не указывать конкретный тип, который будет использоваться.

```
class Account<T>{
     
    private T id;
    private int sum;
     
    Account(T id, int sum){
        this.id = id;
        this.sum = sum;
    }
     
    public T getId() { return id; }
    public int getSum() { return sum; }
    public void setSum(int sum) { this.sum = sum; }
}
```


20. **Класс Object и его методы**

Каждый класс, включая массивы, является потомком java.lang.Object. Всего в java.lang.Object представлено 11 public-методов, 6 из которых имеют нативную реализацию. Так как все классы в Java являются потомками java.lang.Object, то все эти методы унаследованы каждым классом в Java. 

-toString
-clone
-hashCode
-equals
-finalize
-getClass
-wait(long timeout)
-notify()
-notifyAll()

